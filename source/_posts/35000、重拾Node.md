---
title: 35000、重拾Node
date: 2021-06-17 15:51:26
tags:
---

#### 二、给 Node 传递参数

```js
正常执行node程序：node index.js

给node传递一些参数：node index.js env=development zohnny
参数的获取是在process内置对象的argv属性里面，argv是个数组

为什么叫argv呢？
argc：argument counter 参数个数
argv：argument vector
```

#### fs 读写文件

```js
写入文件必须指定编码，不写有默认的编码（utf8===utf-8）
如果指定了编码，读取的时候用了别的编码，到时候读的时候是会乱码的

fs.readFile("./bac.txt",{encoding:'utf-8'},(err,data)=>{
    console.log(data)
})
```

#### npm i 安装原理

```js
事例：安装express框架

符号： "^"
无 lock 文件：
package 版本是：^4.16.1
仓库最新版本是：4.17.1
执行 npm i 安装是是：4.17.1（意味着^的存在是有意义的）

有 lock 文件：
package 版本是：^4.16.1
lock 文件版本：4.17.1
执行 npm i 安装是是：4.17.1

符号： "~"
无 lock 文件：
package 版本是：~4.16.1
仓库最新版本是：4.17.1
执行 npm i 安装是是：4.16.4（意味着~的存在是有意义的）

有 lock 文件：
package 版本是：~4.16.1
lock 文件版本：4.16.1
执行 npm i 安装是是：4.16.1

总结：
有 lock 则版本安装的是 lock 文件里面的版本
无 lock 则安装的是拉取最新版本符合^~规则的

有些可能不是这样：例如axios：
本地package版本：^0.20.0
仓库最新：0.21.1
执行npm i安装的是 0.20.0 并不是 0.21.1
```

#### npx

```js
webpack --version // 全局的
./node_modules/.bin/webpack --version // 找局部的
npx webpack --version
```

#### 模块化引入

```js
CommonJS:可以不带后缀
ESModule：在浏览器环境要带后缀js
AMD不带后缀
```

#### windows 上面执行 npm

```js
实际上执行的是：npm.cmd

在node程序中执行终端命令

所以在子进程里面执行终端命令的时候写代码windows电脑上面要“npm.cmd”
mac电脑不用

node里面怎么获取电脑系统？
const command = process.platform === "win32"?'npm.cmd':'npm'
```

#### 目录结构划分

```js
lib;
--core;
----help.js; // 封装帮助和可选信息
----create.js // 创建指令
----actions.js // 处理函数
--utils
----terminal.js // 执行终端命令的代码
--config
--templates
```

#### 希望实现的功能

```js
zohnny addcpn
zohnny addpage
zohnny create
```

#### 自定义脚手架工具

```js
第一步：
package.json:
"bin": {
    "zohnny": "index.js"
},
然后：npm link 自己的关键字 绑定node

第二步：安装commander
const program = require('commander'); // github:commander

// 查看版本号（zohnny）
program.version(require('./package.json').version);
// -v(小v也可实现查看（第二个参数），多一个步骤)
program.version(require("./package.json").version, "-v,--version"); // 只有这一个会把大写的-v给覆盖掉
program.version(require("./package.json").version);

// 获取帮助信息
helpOptions();

// 创建其他指令(多个)
createCommands();

program.parse(process.argv);
```

```js
// 封装获取帮助信息函数
const helpOptions = () => {
  // 增加自己的options
  program.option("-w --why", "a why cli");
  program.option(
    "-d --dest <dest>",
    "a destination folder, 例如: -d /src/components"
  );
  program.option("-f --framework <framework>", "your frameword");

  program.on("--help", function () {
    console.log("");
    console.log("Other:");
    console.log("  other options~");
  });
};
```

#### 自定义 options 参数获取

```js
以后命令里面-d后面的参数就放在：<dest>里面了，程序里面通过program.dest获取
```

```js
// 封装指令函数
const createCommands = () => {
  program
    .command("create <project> [others...]")
    .description("clone a repository into a folder")
    .action(createProjectAction); // actions
};
```

```js
// actions
// 1.clone项目，用 npm i download-git-repo
// 2.执行npm install
// 3.运行npm run serve
// 4.打开浏览器用 npm i open

// 一、克隆项目
// 1.克隆项目用到第三方库：
const download = promisify(require("download-git-repo"));
// 2.因为download函数是里面容易形成回调地狱，所以通过 promisify 转化成promise
const { promisify } = require("util");
// download函数传入三个参数：要克隆的仓库地址、项目的名字、options

// 二、自动执行npm install
// 1.判断当前操作系统环境
// 2.封装执行子进程的函数

// callback -> promisify(函数) -> Promise -> async await
const createProjectAction = async (project) => {
  console.log("why helps you create your project~");

  // 1.clone项目
  await download(vueRepo, project, { clone: true });

  // 2.执行npm install
  const command = process.platform === "win32" ? "npm.cmd" : "npm";
  await commandSpawn(command, ["install"], { cwd: `./${project}` });

  // 3.运行npm run serve
  commandSpawn(command, ["run", "serve"], { cwd: `./${project}` }); // 这里不要用await，npm run serve自己不ctrl+c的话await是不会退出的，会一直等，下面代码不执行

  // 4.打开浏览器
  open("http://localhost:8080/");
};
```

```js
// 新开子进程--->执行终端命令
const { spawn } = require("child_process"); // node官网
// 参数是：(npm,["run","serve"],配置对象{cwd:`/${project}`})  ---当前工作目录

// npm install
const commandSpawn = (...args) => {
  return new Promise((resolve, reject) => {
    const childProcess = spawn(...args); // 返回一个进程对象
    childProcess.stdout.pipe(process.stdout); //  把子进程相关的输出信息移植到主进程
    childProcess.stderr.pipe(process.stderr);
    // 监听进程执行完毕，后续代码继续执行
    childProcess.on("close", () => {
      resolve();
    });
  });
};
```

#### 添加一个组件模板：zohnny addcpn Home -d "src/components"

```js
添加一个组件，必须先有一个模板，前端用的最多的就是ejs
实现逻辑：敲命令，模板转化成.vue文件，再把文件写入到destination目标文件夹里面
1.有对应的ejs模板
2.编译ejs模板--->得到字符串（npm i ejs）
    ejs.renderFile(文件路径,{传递的参数},options,(err,result)=>{})
3.将字符串写入到.vue文件中
    用到fs、path模块
4.将vue文件放入到目标文件夹

```

#### 总逻辑

```js
1.先定义指令
program
    .command("addcpn <name>")
    .description('add vue component,例如：zohnny addcpn HelloWorld [-d src/components]')
    .action((name)=>{
        addComponentAction( name , program.dest || "src/components") // 命令行终端敲下命令，就会执行这个action
    })

2.添加组件的action
const addComponentAction = async (name,dest) => {
    // 1.编译ejs模板得到result
    // 前提是有模板
    const result = await compile("vue-component.ejs",{name,lowerName:name.toLowerCase()})

    // 2.写入文件的操作
    const targetPath = path.resolve(dest,`${name}.vue`)
    console.log(targetPath)
    writeToFile(targetPath,result);
}

3.封装编译模板的函数compile
const compile = (templateName,data) => {
    const templatePosition = `../templates/${templateName}}`;
    const templatePath = path.resolve(__dirname,templatePosition)

    return new Promise((resolve,reject)=>{
        ejs.renderFile(templatePath,{data},{},(err,result)=>{
            // 需要模板的绝对路径
            if(err){
                console.log(err)
                reject(err)
                return
            }
            resolve(result)
        })
    })
}

4.封装写入文件函数writeToFile
const writeToFile = (path,content) => {
    return fs.promises.writeFile(path,content)
}
```

#### ejs 变量细节

```js
ejs.renderFile(文件路径,{传递的参数},options,(err,result)=>{})

ejsObject：是编译ejs的时候传递过来的对象，对象里面有很多变量
ejs语法:哪里用到的要替换的变量直接用：<%= ejsObject.variable %> 替代原来的变量即可，不管字符串的引号等等，直接放
```
